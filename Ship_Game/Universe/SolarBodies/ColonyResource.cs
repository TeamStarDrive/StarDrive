using System;

namespace Ship_Game.Universe.SolarBodies
{
    public abstract class ColonyResource
    {
        protected readonly Planet Planet;
        public float Percent; // Percentage workers allocated [0.0-1.0]
        public bool PercentLock; // Percentage slider locked by user

        // Per Turn: Raw value produced before we apply any taxes or consume stuff
        public float GrossIncome { get; protected set; }

        // Per Turn: NetIncome = GrossIncome - (taxes + consumption)
        public float NetIncome { get; protected set; }

        // Per Turn: GrossIncome assuming we have MaxPopulation
        public float MaxPotential { get; protected set; }

        // Per Turn: Flat income added; no taxes applied
        public float FlatBonus { get; protected set; }

        // Per Turn: NetFlatBonus = FlatBonus - tax
        public float NetFlatBonus { get; protected set; }

        // Per Turn: Resources generated by colonists
        public float YieldPerColonist { get; protected set; }

        // Per Turn: NetYieldPerColonist = YieldPerColonist - taxes
        public float NetYieldPerColonist { get; protected set; }

        protected ColonyResource(Planet planet) { Planet = planet; }

        protected abstract void RecalculateModifiers();

        public virtual void Update(float consumption)
        {
            FlatBonus = 0f;
            RecalculateModifiers();
            
            float products = YieldPerColonist * Percent * Planet.PopulationBillion;
            MaxPotential = YieldPerColonist * Planet.MaxPopulationBillion;
            GrossIncome = FlatBonus + products;

            // taxes get applied before consumption
            // because government gets to eat their pie first :)))
            // @note Taxes affect all aspects of life: Food, Prod and Research.
            float tax = Planet.Owner.data.TaxRate;
            NetIncome    = GrossIncome  - (GrossIncome*tax + consumption);
            NetFlatBonus = NetFlatBonus - (NetFlatBonus*tax);
            NetYieldPerColonist = YieldPerColonist - (YieldPerColonist*tax);
        }

        public void AutoBalanceWorkers(float otherWorkers)
        {
            Percent = Math.Max(1f - otherWorkers, 0f);
        }

        public void AutoBalanceWorkers()
        {
            ColonyResource a, b;
            if      (this == Planet.Food) { a = Planet.Prod; b = Planet.Res;  }
            else if (this == Planet.Prod) { a = Planet.Food; b = Planet.Res;  }
            else if (this == Planet.Res)  { a = Planet.Food; b = Planet.Prod; }
            else return; // we're not Food,Prod,Res, so bail out
            AutoBalanceWorkers(a.Percent + b.Percent);
        }

        // Nominal workers needed to neither gain nor lose storage
        // @param desiredPerTurn Extra buffer of production per turn
        // @param flat Extra flat bonus to use in calculation
        // @param perCol Extra per colonist bonus to use in calculation
        public virtual float WorkersNeededForEquilibrium(float desiredPerTurn = 0.0f, float flat = 0.0f, float perCol = 0.0f)
        {
            if (Planet.Population <= 0 || 
                this == Planet.Food && Planet.IsCybernetic ||
                this == Planet.Prod && Planet.NonCybernetic)
                return 0;

            float yield = YieldPerColonist + perCol;
            if (this == Planet.Food && yield <= 0.5f)
                return 0; // we won't be making any food here

            float needed = Planet.Consumption - (FlatBonus + flat) + desiredPerTurn;
            float fromAllColonists = yield * Planet.PopulationBillion;
            float minWorkers = needed / fromAllColonists;
            return minWorkers.Clamped(0.0f, 0.9f);
        }
    }


    public class ColonyFood : ColonyResource
    {
        public ColonyFood(Planet planet) : base(planet)
        {
        }

        protected override void RecalculateModifiers()
        {
            float plusPerColonist = 0f;
            foreach (Building b in Planet.BuildingList)
            {
                plusPerColonist += b.PlusFoodPerColonist;
                FlatBonus       += b.PlusFlatFoodAmount;
            }
            YieldPerColonist = Planet.Fertility + plusPerColonist;
        }

        public override void Update(float consumption)
        {
            base.Update(Planet.IsCybernetic ? 0f : consumption);
        }
    }

    public class ColonyProd : ColonyResource
    {
        public ColonyProd(Planet planet) : base(planet)
        {
        }

        protected override void RecalculateModifiers()
        {
            float richness = Planet.MineralRichness;
            float plusPerColonist = 0f;
            foreach (Building b in Planet.BuildingList)
            {
                plusPerColonist += b.PlusProdPerColonist;
                FlatBonus += b.PlusProdPerRichness * richness;
                FlatBonus += b.PlusFlatProductionAmount;
            }
            float productMod = Planet.Owner.data.Traits.ProductionMod;
            YieldPerColonist = (richness + plusPerColonist) * (1 + productMod);
        }

        public override void Update(float consumption)
        {
            base.Update(Planet.IsCybernetic ? consumption : 0f);
        }
    }

    public class ColonyRes : ColonyResource
    {
        public ColonyRes(Planet planet) : base(planet)
        {
        }

        protected override void RecalculateModifiers()
        {
            float plusPerColonist = 0f;
            foreach (Building b in Planet.BuildingList)
            {
                plusPerColonist += b.PlusResearchPerColonist;
                FlatBonus       += b.PlusFlatResearchAmount;
            }
            float researchMod = Planet.Owner.data.Traits.ResearchMod;
            // @note Research only comes from buildings
            // Outposts and Capital Cities always grant a small bonus
            YieldPerColonist = plusPerColonist * (1 + researchMod);
        }

        public override void Update(float consumption)
        {
            base.Update(0f/*research not consumed*/);
        }
    }
}
