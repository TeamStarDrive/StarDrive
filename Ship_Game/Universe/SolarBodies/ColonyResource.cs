using System;
using SDGraphics;
using Ship_Game.Data.Serialization;
using Ship_Game.Ships;

namespace Ship_Game.Universe.SolarBodies
{
    [StarDataType]
    public abstract class ColonyResource
    {
        [StarData] protected readonly Planet Planet;
        [StarData] float AveragePercent;
        public bool Initialized { get; private set; }

        float PercentValue;
        [StarData] public float Percent // Percentage workers allocated [0.0-1.0]
        {
            get => PercentValue;
            set => PercentValue = value.NaNChecked(0f, "Resource.Percent");
        }

        [StarData] public bool PercentLock; // Percentage slider locked by user

        // Per Turn: Raw value produced before we apply any taxes or consume stuff
        public float GrossIncome { get; protected set; }

        // Per Turn: NetIncome = GrossIncome - (taxes + consumption)
        public float NetIncome { get; protected set; }

        // Per Turn: GrossIncome assuming we have Percent=1
        public float GrossMaxPotential { get; protected set; }

        // Per Turn: NetMaxPotential = GrossMaxPotential - (taxes + consumption)
        public float NetMaxPotential { get; protected set; }

        // Per Turn: Flat income added; no taxes applied
        public float FlatBonus { get; protected set; }

        // Per Turn: NetFlatBonus = FlatBonus - tax
        public float NetFlatBonus { get; protected set; }

        // Per Turn: Resources generated by colonists
        public float YieldPerColonist { get; protected set; }

        // Per Turn: NetYieldPerColonist = YieldPerColonist - taxes
        public float NetYieldPerColonist { get; protected set; }

        protected float Tax; // ex: 0.25 for 25% tax rate
        public float AfterTax(float grossValue) => grossValue - grossValue*Tax;

        [StarDataConstructor]
        protected ColonyResource(Planet planet) { Planet = planet; }

        protected abstract void RecalculateModifiers();

        // Purely used for estimation
        protected virtual float AvgResourceConsumption() => 0.0f;

        // For Food Per Colonist output
        static public float FoodYieldFormula(float fertility, float plusPerColonist) 
            => fertility * (1 + plusPerColonist);

        // For Production Per Colonist output
        static public float ProdYieldFormula(float richness, float plusPerColonist, Empire owner) 
            => richness * (1 + plusPerColonist) * (1 + owner.data.Traits.ProductionMod);

        public virtual void Update(float consumption)
        {
            Initialized = true;
            FlatBonus = 0f;
            RecalculateModifiers();

            GrossMaxPotential = YieldPerColonist * Planet.PopulationBillion;
            GrossIncome = FlatBonus + Percent * GrossMaxPotential;

            // taxes get applied before consumption
            // because government gets to eat their pie first :)))
            NetIncome           = AfterTax(GrossIncome) - consumption;
            NetMaxPotential     = AfterTax(GrossMaxPotential+FlatBonus) - consumption;
            NetFlatBonus        = AfterTax(FlatBonus);
            NetYieldPerColonist = AfterTax(YieldPerColonist);
        }

        public float ColonistIncome(float yieldPerColonist)
        {
            return Percent * yieldPerColonist * Planet.PopulationBillion;
        }

        public void CalculateAveragePercentage()
        {
            AveragePercent = HelperFunctions.ExponentialMovingAverage(AveragePercent, Percent);
        }

        public void ResetAveragePercentage()
        {
            AveragePercent = 0;
        }

        public float GetAveragePercent()
        {
            if (AveragePercent < 0.05) return 0;
            else if (AveragePercent > 0.95) return 1;
            else return AveragePercent;
        }

        // Nominal workers needed to neither gain nor lose storage
        // @param flat Extra flat bonus to use in calculation
        public float WorkersNeededForEquilibrium(float addFlat = 0)
        {
            if (Planet.Population <= 0 || NetYieldPerColonist.LessOrEqual(0))
                return 0;

            float needed        = AvgResourceConsumption() - NetFlatBonus + addFlat;
            float workersNeeded = needed / NetYieldPerColonist;
            float minWorkers    = (workersNeeded / Planet.PopulationBillion).LowerBound(0);

            return minWorkers.NaNChecked(0f, "WorkersNeededForEquilibrium").Clamped(0.0f, 0.9f);
        }

        public float EstPercentForNetIncome(float targetNetIncome)
        {
            float flat = (targetNetIncome) / (1f - Tax);
            return WorkersNeededForEquilibrium(flat);
        }


        public void AutoBalanceWorkers(float otherWorkers)
        {
            Percent = Math.Max(1f - otherWorkers, 0f);
        }

        public void AutoBalanceWorkers()
        {
            bool noResearch = Planet.Owner.Research.NoTopic
                              && Planet.CType != Planet.ColonyType.Colony
                              && Planet.CType != Planet.ColonyType.TradeHub;

            ColonyResource a, b;
            if      (this == Planet.Food) { a = Planet.Prod; b = Planet.Res;  }
            else if (this == Planet.Prod) { a = Planet.Food; b = Planet.Res;  }
            else if (this == Planet.Res)  { a = Planet.Food; b = Planet.Prod; }
            else return; // we're not Food,Prod,Res, so bail out

            if (this == Planet.Res && (Planet.Res.YieldPerColonist.AlmostZero() || noResearch))
                // no need to assign research since no capacity available or no research in progress.
                AutoBalanceWithZeroResearch(a, b);
            else
                AutoBalanceWorkers(a.Percent + b.Percent);
        }

        public void AutoBalanceWithZeroResearch(ColonyResource food, ColonyResource prod)
        {
            float remainder = 1 - (food.Percent + prod.Percent);
            prod.Percent   += remainder;
        }
    }

    [StarDataType]
    public class ColonyFood : ColonyResource
    {
        [StarDataConstructor]
        public ColonyFood(Planet planet) : base(planet)
        {
        }

        protected override void RecalculateModifiers()
        {
            float plusPerColonist = 0f;
            foreach (Building b in Planet.Buildings)
            {
                plusPerColonist += b.PlusFoodPerColonist.LowerBound(0);
                FlatBonus       += b.PlusFlatFoodAmount;
            }

            float fertility  = Planet.Fertility;
            YieldPerColonist = FoodYieldFormula(fertility, plusPerColonist);

            Tax = 0f;
            // If we use tax effects with Food resource,
            // we need a base yield offset for balance
            //YieldPerColonist += 0.25f;
        }

        protected override float AvgResourceConsumption()
        {
            return Planet.NonCybernetic ? Planet.Consumption : 0f;
        }

        public override void Update(float consumption)
        {
            base.Update(Planet.NonCybernetic ? consumption : 0f);
        }
    }
    
    [StarDataType]
    public class ColonyProduction : ColonyResource
    {
        [StarDataConstructor]
        public ColonyProduction(Planet planet) : base(planet)
        {
        }

        protected override void RecalculateModifiers()
        {
            float richness = Planet.MineralRichness;
            float plusPerColonist = 0f;
            foreach (Building b in Planet.Buildings)
            {
                plusPerColonist += b.PlusProdPerColonist.LowerBound(0);
                FlatBonus       += b.PlusProdPerRichness * richness;
                FlatBonus       += b.PlusFlatProductionAmount;
            }

            float exoticProduction = Planet.Owner.GetStaticExoticBonusMuliplier(ExoticBonusType.Production);
            YieldPerColonist = ProdYieldFormula(richness, plusPerColonist, Planet.Owner) * exoticProduction;
            if (Planet.System.EmpireOwnsDysonSwarm(Planet.Owner))
                FlatBonus += Planet.System.DysonSwarm.ProductionBoost;

            FlatBonus *= exoticProduction;

            // Cybernetics consume production and will starve at 100% tax, so ease up on them
            Tax = Planet.NonCybernetic || Planet.OwnerIsPlayer ? Planet.Owner.data.TaxRate : Planet.Owner.data.TaxRate  * 0.5f;
        }

        protected override float AvgResourceConsumption()
        {
            return Planet.IsCybernetic ? Planet.Consumption : 0f;
        }

        public override void Update(float consumption)
        {
            base.Update(Planet.IsCybernetic ? consumption : 0f);
        }
    }
    
    [StarDataType]
    public class ColonyResearch : ColonyResource
    {
        [StarDataConstructor]
        public ColonyResearch(Planet planet) : base(planet)
        {
        }

        protected override void RecalculateModifiers()
        {
            float plusPerColonist = 0f;
            foreach (Building b in Planet.Buildings)
            {
                plusPerColonist += b.PlusResearchPerColonist.LowerBound(0);
                FlatBonus       += b.PlusFlatResearchAmount;
            }

            // We allow negative flat bonus per building to offset other efforts.
            // But net bonus cannot be negative - so negative flat research buildings are an offset
            float researchMod = Planet.Owner.data.Traits.ResearchMod;
            FlatBonus         = FlatBonus.LowerBound(0) * (1 + researchMod);
            // @note Research only comes from buildings
            // Outposts and Capital Cities always grant a small bonus
            YieldPerColonist = plusPerColonist * (1 + researchMod);

            Tax = Planet.Owner.data.TaxRate * Planet.Owner.data.Traits.ResearchTaxMultiplier;
        }

        // @todo Estimate how much research we need
        protected override float AvgResourceConsumption() => 4.0f; // This is a good MINIMUM research value for estimation
    }

    public class ColonyMoney
    {
        readonly Planet Planet;
        public float IncomePerColonist { get; private set; }

        // The current tax rate applied by empire tax rate and planet tax rate modifiers
        public float TaxRate { get; private set; }

        // revenue before maintenance is deducted
        public float GrossRevenue { get; private set; }

        // maintenance costs from all buildings, with maintenance multiplier applied
        public float Maintenance { get; private set; }

        // some buildings provide flat income
        public float IncomeFromBuildings { get; private set; }

        // revenue after maintenance was deducted
        public float NetRevenue { get; private set; }

        // Troops on planet Maintenance
        public float TroopMaint { get; private set; }

        // Maximum Revenue from this planet if Tax is 100%
        public float PotentialRevenue { get; private set; }

        public ColonyMoney(Planet planet) { Planet = planet; }

        public float NetRevenueGain(Building b)
        {
            float newPopulation = b.MaxPopIncrease*0.001f;
            if (b.IsBiospheres)
                newPopulation += Planet.PopPerBiosphere(Planet.Owner)*0.001f;

            float grossIncome = newPopulation * IncomePerColonist * TaxRate;
            return grossIncome - b.ActualMaintenance(Planet);
        }

        public void Update()
        {
            // Base tax rate comes from current empire tax %
            TaxRate = Planet.Owner.data.TaxRate;

            Maintenance         = 0f;
            IncomePerColonist   = 1f;
            IncomeFromBuildings = 0f;
            float taxRateMultiplier = 1f + Planet.Owner.data.Traits.TaxMod;

            foreach (Building b in Planet.Buildings)
            {
                IncomePerColonist   += b.CreditsPerColonist;
                taxRateMultiplier   += b.PlusTaxPercentage;
                Maintenance         += b.Maintenance.LowerBound(0);
                IncomeFromBuildings += b.Income;
            }

            TroopMaint = Planet.Troops.Count * ShipMaintenance.TroopMaint; // We count enemy troops as well

            // And finally we adjust local TaxRate by the bonus multiplier
            TaxRate     *= taxRateMultiplier;
            Maintenance *= Planet.Owner.data.Traits.MaintMultiplier;

            GrossRevenue = ((Planet.PopulationBillion * IncomePerColonist) + IncomeFromBuildings) * TaxRate;
            NetRevenue   = GrossRevenue - Maintenance;

            // Needed for empire treasury goal
            PotentialRevenue = ((Planet.PopulationBillion * IncomePerColonist) + IncomeFromBuildings) * taxRateMultiplier;
        }
    }
}
